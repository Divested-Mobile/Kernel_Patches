From 2c031d0e5577629f3179766a6d262496b17b460e Mon Sep 17 00:00:00 2001
From: Mohammed Javid <mjavid@codeaurora.org>
Date: Thu, 15 Jun 2017 15:39:04 +0530
Subject: [PATCH] msm:ipa: Fix to incorrect structure access

Accessing of incorrect structure pointer is causing
memory out of bound access, fixed issue by accessing
the correct structure pointer.

Bug: 63851638
Change-Id: I3c2f5f7a97cac854093ef670184d06db4231f5e1
Acked-by: Ashok Vuyyuru <avuyyuru@qti.qualcomm.com>
Signed-off-by: Mohammed Javid <mjavid@codeaurora.org>
Signed-off-by: Siqi Lin <siqilin@google.com>
[haggertk: Backport to 3.4/msm8974
 NOTE: No current lineage targets for this kernel make use of this
 driver]
CVE-2017-14879
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 drivers/platform/msm/ipa/ipa_flt.c | 18 +++++++++++-------
 drivers/platform/msm/ipa/ipa_hdr.c | 17 +++++++++++++----
 drivers/platform/msm/ipa/ipa_i.h   | 13 +++++++++----
 drivers/platform/msm/ipa/ipa_rt.c  | 29 +++++++++++++++++++----------
 4 files changed, 52 insertions(+), 25 deletions(-)

diff --git a/drivers/platform/msm/ipa/ipa_flt.c b/drivers/platform/msm/ipa/ipa_flt.c
index 2a8bf923a75..af6ecd63843 100644
--- a/drivers/platform/msm/ipa/ipa_flt.c
+++ b/drivers/platform/msm/ipa/ipa_flt.c
@@ -539,7 +539,7 @@ static int __ipa_add_flt_rule(struct ipa_flt_tbl *tbl, enum ipa_ip_type ip,
 		}
 
 		if (((struct ipa_rt_tbl *)rule->rt_tbl_hdl)->cookie !=
-				IPA_COOKIE) {
+				IPA_RT_TBL_COOKIE) {
 			IPAERR("RT table cookie is invalid\n");
 			goto error;
 		}
@@ -554,11 +554,11 @@ static int __ipa_add_flt_rule(struct ipa_flt_tbl *tbl, enum ipa_ip_type ip,
 	entry = kmem_cache_zalloc(ipa_ctx->flt_rule_cache, GFP_KERNEL);
 	if (!entry) {
 		IPAERR("failed to alloc FLT rule object\n");
-		goto mem_alloc_fail;
+		goto error;
 	}
 	INIT_LIST_HEAD(&entry->link);
 	entry->rule = *rule;
-	entry->cookie = IPA_COOKIE;
+	entry->cookie = IPA_FLT_COOKIE;
 	entry->rt_tbl = (struct ipa_rt_tbl *)rule->rt_tbl_hdl;
 	entry->tbl = tbl;
 	if (add_rear)
@@ -575,12 +575,16 @@ static int __ipa_add_flt_rule(struct ipa_flt_tbl *tbl, enum ipa_ip_type ip,
 	if (ipa_insert(&ipa_ctx->flt_rule_hdl_tree, node)) {
 		IPAERR("failed to add to tree\n");
 		WARN_ON(1);
+		goto ipa_insert_failed;
 	}
 
 	return 0;
-
-mem_alloc_fail:
-	kmem_cache_free(ipa_ctx->tree_node_cache, node);
+ipa_insert_failed:
+	tbl->rule_cnt--;
+	if (entry->rt_tbl)
+		entry->rt_tbl->ref_cnt--;
+	list_del(&entry->link);
+	kmem_cache_free(ipa_ctx->flt_rule_cache, entry);
 error:
 
 	return -EPERM;
@@ -598,7 +602,7 @@ static int __ipa_del_flt_rule(u32 rule_hdl)
 		return -EINVAL;
 	}
 
-	if (entry == NULL || (entry->cookie != IPA_COOKIE)) {
+	if (entry == NULL || (entry->cookie != IPA_FLT_COOKIE)) {
 		IPAERR("bad params\n");
 
 		return -EINVAL;
diff --git a/drivers/platform/msm/ipa/ipa_hdr.c b/drivers/platform/msm/ipa/ipa_hdr.c
index 9bebd651108..8315eb2c6fd 100644
--- a/drivers/platform/msm/ipa/ipa_hdr.c
+++ b/drivers/platform/msm/ipa/ipa_hdr.c
@@ -140,7 +140,7 @@ static int __ipa_commit_hdr(void)
 static int __ipa_add_hdr(struct ipa_hdr_add *hdr)
 {
 	struct ipa_hdr_entry *entry;
-	struct ipa_hdr_offset_entry *offset;
+	struct ipa_hdr_offset_entry *offset = NULL;
 	struct ipa_tree_node *node;
 	u32 bin;
 	struct ipa_hdr_tbl *htbl = &ipa_ctx->hdr_tbl;
@@ -168,7 +168,7 @@ static int __ipa_add_hdr(struct ipa_hdr_add *hdr)
 	entry->hdr_len = hdr->hdr_len;
 	strlcpy(entry->name, hdr->name, IPA_RESOURCE_NAME_MAX);
 	entry->is_partial = hdr->is_partial;
-	entry->cookie = IPA_COOKIE;
+	entry->cookie = IPA_HDR_COOKIE;
 
 	if (hdr->hdr_len <= ipa_hdr_bin_sz[IPA_HDR_BIN0])
 		bin = IPA_HDR_BIN0;
@@ -219,6 +219,7 @@ static int __ipa_add_hdr(struct ipa_hdr_add *hdr)
 	if (ipa_insert(&ipa_ctx->hdr_hdl_tree, node)) {
 		IPAERR("failed to add to tree\n");
 		WARN_ON(1);
+		 goto ipa_insert_failed;
 	}
 
 	entry->ref_cnt++;
@@ -227,6 +228,14 @@ static int __ipa_add_hdr(struct ipa_hdr_add *hdr)
 
 ofst_alloc_fail:
 	kmem_cache_free(ipa_ctx->hdr_offset_cache, offset);
+ipa_insert_failed:
+	if (offset)
+		list_move(&offset->link,
+			  &htbl->head_free_offset_list[offset->bin]);
+	entry->offset_entry = NULL;
+
+	htbl->hdr_cnt--;
+	list_del(&entry->link);
 bad_hdr_len:
 	entry->cookie = 0;
 	kmem_cache_free(ipa_ctx->hdr_cache, entry);
@@ -248,7 +257,7 @@ int __ipa_del_hdr(u32 hdr_hdl, bool by_user)
 		return -EINVAL;
 	}
 
-	if (!entry || (entry->cookie != IPA_COOKIE)) {
+	if (!entry || (entry->cookie != IPA_HDR_COOKIE)) {
 		IPAERR("bad parm\n");
 		return -EINVAL;
 	}
@@ -613,7 +622,7 @@ int ipa_put_hdr(u32 hdr_hdl)
 		goto bail;
 	}
 
-	if (entry == NULL || entry->cookie != IPA_COOKIE) {
+	if (entry == NULL || entry->cookie != IPA_HDR_COOKIE) {
 		IPAERR("bad params\n");
 		result = -EINVAL;
 		goto bail;
diff --git a/drivers/platform/msm/ipa/ipa_i.h b/drivers/platform/msm/ipa/ipa_i.h
index deeffb286d7..c8bdcdd71f4 100644
--- a/drivers/platform/msm/ipa/ipa_i.h
+++ b/drivers/platform/msm/ipa/ipa_i.h
@@ -28,6 +28,11 @@
 
 #define DRV_NAME "ipa"
 #define IPA_COOKIE 0xfacefeed
+#define IPA_RT_RULE_COOKIE 0xfacefeef
+#define IPA_RT_TBL_COOKIE 0xfacefef0
+#define IPA_FLT_COOKIE 0xfacefef1
+#define IPA_HDR_COOKIE 0xfacefef2
+#define IPA_PROC_HDR_COOKIE 0xfacefef3
 
 #define IPA_NUM_PIPES 0x14
 #define IPA_SYS_DESC_FIFO_SZ 0x800
@@ -179,8 +184,8 @@ struct ipa_mem_buffer {
  */
 struct ipa_flt_entry {
 	struct list_head link;
-	struct ipa_flt_rule rule;
 	u32 cookie;
+	struct ipa_flt_rule rule;
 	struct ipa_flt_tbl *tbl;
 	struct ipa_rt_tbl *rt_tbl;
 	u32 hw_len;
@@ -203,13 +208,13 @@ struct ipa_flt_entry {
  */
 struct ipa_rt_tbl {
 	struct list_head link;
+	u32 cookie;
 	struct list_head head_rt_rule_list;
 	char name[IPA_RESOURCE_NAME_MAX];
 	u32 idx;
 	u32 rule_cnt;
 	u32 ref_cnt;
 	struct ipa_rt_tbl_set *set;
-	u32 cookie;
 	bool in_sys;
 	u32 sz;
 	struct ipa_mem_buffer curr_mem;
@@ -230,12 +235,12 @@ struct ipa_rt_tbl {
  */
 struct ipa_hdr_entry {
 	struct list_head link;
+	u32 cookie;
 	u8 hdr[IPA_HDR_MAX_SIZE];
 	u32 hdr_len;
 	char name[IPA_RESOURCE_NAME_MAX];
 	u8 is_partial;
 	struct ipa_hdr_offset_entry *offset_entry;
-	u32 cookie;
 	u32 ref_cnt;
 	bool user_deleted;
 };
@@ -298,8 +303,8 @@ struct ipa_flt_tbl {
  */
 struct ipa_rt_entry {
 	struct list_head link;
-	struct ipa_rt_rule rule;
 	u32 cookie;
+	struct ipa_rt_rule rule;
 	struct ipa_rt_tbl *tbl;
 	struct ipa_hdr_entry *hdr;
 	u32 hw_len;
diff --git a/drivers/platform/msm/ipa/ipa_rt.c b/drivers/platform/msm/ipa/ipa_rt.c
index 1f45af0268b..5220ef22d48 100644
--- a/drivers/platform/msm/ipa/ipa_rt.c
+++ b/drivers/platform/msm/ipa/ipa_rt.c
@@ -505,7 +505,7 @@ static struct ipa_rt_tbl *__ipa_add_rt_tbl(enum ipa_ip_type ip,
 		INIT_LIST_HEAD(&entry->link);
 		strlcpy(entry->name, name, IPA_RESOURCE_NAME_MAX);
 		entry->set = set;
-		entry->cookie = IPA_COOKIE;
+		entry->cookie = IPA_RT_TBL_COOKIE;
 		entry->in_sys = (ip == IPA_IP_v4) ?
 			!ipa_ctx->ip4_rt_tbl_lcl : !ipa_ctx->ip6_rt_tbl_lcl;
 		set->tbl_cnt++;
@@ -518,6 +518,7 @@ static struct ipa_rt_tbl *__ipa_add_rt_tbl(enum ipa_ip_type ip,
 		if (ipa_insert(&ipa_ctx->rt_tbl_hdl_tree, node)) {
 			IPAERR("failed to add to tree\n");
 			WARN_ON(1);
+			goto ipa_insert_failed;
 		}
 	} else {
 		kmem_cache_free(ipa_ctx->tree_node_cache, node);
@@ -525,6 +526,9 @@ static struct ipa_rt_tbl *__ipa_add_rt_tbl(enum ipa_ip_type ip,
 
 	return entry;
 
+ipa_insert_failed:
+	set->tbl_cnt--;
+	list_del(&entry->link);
 fail_rt_idx_alloc:
 	entry->cookie = 0;
 	kmem_cache_free(ipa_ctx->rt_tbl_cache, entry);
@@ -539,7 +543,7 @@ static int __ipa_del_rt_tbl(struct ipa_rt_tbl *entry)
 	struct ipa_tree_node *node;
 	enum ipa_ip_type ip = IPA_IP_MAX;
 
-	if (entry == NULL || (entry->cookie != IPA_COOKIE)) {
+	if (entry == NULL || (entry->cookie != IPA_RT_TBL_COOKIE)) {
 		IPAERR("bad parms\n");
 		return -EINVAL;
 	}
@@ -553,8 +557,10 @@ static int __ipa_del_rt_tbl(struct ipa_rt_tbl *entry)
 		ip = IPA_IP_v4;
 	else if (entry->set == &ipa_ctx->rt_tbl_set[IPA_IP_v6])
 		ip = IPA_IP_v6;
-	else
+	else {
 		WARN_ON(1);
+		return -EPERM;
+	}
 
 	if (!entry->in_sys) {
 		list_del(&entry->link);
@@ -588,7 +594,7 @@ static int __ipa_add_rt_rule(enum ipa_ip_type ip, const char *name,
 
 	if (rule->hdr_hdl &&
 	    ((ipa_search(&ipa_ctx->hdr_hdl_tree, rule->hdr_hdl) == NULL) ||
-	     ((struct ipa_hdr_entry *)rule->hdr_hdl)->cookie != IPA_COOKIE)) {
+	     ((struct ipa_hdr_entry *)rule->hdr_hdl)->cookie != IPA_HDR_COOKIE)) {
 		IPAERR("rt rule does not point to valid hdr\n");
 		goto error;
 	}
@@ -600,7 +606,7 @@ static int __ipa_add_rt_rule(enum ipa_ip_type ip, const char *name,
 	}
 
 	tbl = __ipa_add_rt_tbl(ip, name);
-	if (tbl == NULL || (tbl->cookie != IPA_COOKIE)) {
+	if (tbl == NULL || (tbl->cookie != IPA_RT_TBL_COOKIE)) {
 		IPAERR("bad params\n");
 		goto fail_rt_tbl_sanity;
 	}
@@ -621,7 +627,7 @@ static int __ipa_add_rt_rule(enum ipa_ip_type ip, const char *name,
 		goto fail_rt_tbl_sanity;
 	}
 	INIT_LIST_HEAD(&entry->link);
-	entry->cookie = IPA_COOKIE;
+	entry->cookie = IPA_RT_RULE_COOKIE;
 	entry->rule = *rule;
 	entry->tbl = tbl;
 	entry->hdr = (struct ipa_hdr_entry *)rule->hdr_hdl;
@@ -709,7 +715,7 @@ int __ipa_del_rt_rule(u32 rule_hdl)
 		return -EINVAL;
 	}
 
-	if (entry == NULL || (entry->cookie != IPA_COOKIE)) {
+	if (entry == NULL || (entry->cookie != IPA_RT_RULE_COOKIE)) {
 		IPAERR("bad params\n");
 		return -EINVAL;
 	}
@@ -936,7 +942,7 @@ int ipa_get_rt_tbl(struct ipa_ioc_get_rt_tbl *lookup)
 	}
 	mutex_lock(&ipa_ctx->lock);
 	entry = __ipa_add_rt_tbl(lookup->ip, lookup->name);
-	if (entry && entry->cookie == IPA_COOKIE) {
+	if (entry && entry->cookie == IPA_RT_TBL_COOKIE) {
 		if (entry->ref_cnt == ((u32)~0U)) {
 			IPAERR("fail: ref count crossed limit\n");
 			goto ret;
@@ -981,7 +987,7 @@ int ipa_put_rt_tbl(u32 rt_tbl_hdl)
 		goto ret;
 	}
 
-	if (entry == NULL || (entry->cookie != IPA_COOKIE) ||
+	if (entry == NULL || (entry->cookie != IPA_RT_TBL_COOKIE) ||
 			entry->ref_cnt == 0) {
 		IPAERR("bad parms\n");
 		result = -EINVAL;
@@ -992,8 +998,11 @@ int ipa_put_rt_tbl(u32 rt_tbl_hdl)
 		ip = IPA_IP_v4;
 	else if (entry->set == &ipa_ctx->rt_tbl_set[IPA_IP_v6])
 		ip = IPA_IP_v6;
-	else
+	else {
 		WARN_ON(1);
+		result = -EINVAL;
+		goto ret;
+	}
 
 	entry->ref_cnt--;
 	if (entry->ref_cnt == 0 && entry->rule_cnt == 0) {
