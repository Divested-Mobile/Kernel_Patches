From c1a7b4b4a736fa175488122cca9743cff2ae72e8 Mon Sep 17 00:00:00 2001
From: Sanjay Yadav <quic_sanjyada@quicinc.com>
Date: Wed, 31 Jan 2024 17:59:36 +0530
Subject: [PATCH] msm: kgsl: Do not reclaim pages mapped in a VBO

Pages mapped into a VBO can be accessible both through the memdesc as well
as through the parent VBO. Reclaiming these pages would require a lot of
overhead to update iommu mappings. Instead, do not reclaim the pages of a
memdesc that is currently mapped in a VBO.

Change-Id: Ic2787f09081c5dc3a66c3582b98266937c8ce1e5
Signed-off-by: Lynus Vaz <quic_lvaz@quicinc.com>
Signed-off-by: Sanjay Yadav <quic_sanjyada@quicinc.com>
---
 drivers/gpu/msm/kgsl.c         |  1 +
 drivers/gpu/msm/kgsl.h         |  4 +++-
 drivers/gpu/msm/kgsl_reclaim.c |  9 ++++++++-
 drivers/gpu/msm/kgsl_vbo.c     | 15 +++++++++++++--
 4 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index 6a7632a83eb42..2c88eab6656d0 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -268,6 +268,7 @@ static struct kgsl_mem_entry *kgsl_mem_entry_create(void)
 		/* put this ref in userspace memory alloc and map ioctls */
 		kref_get(&entry->refcount);
 		atomic_set(&entry->map_count, 0);
+		atomic_set(&entry->vbo_count, 0);
 	}
 
 	return entry;
diff --git a/drivers/gpu/msm/kgsl.h b/drivers/gpu/msm/kgsl.h
index a47e91bc6845b..288fa83ff262f 100644
--- a/drivers/gpu/msm/kgsl.h
+++ b/drivers/gpu/msm/kgsl.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #ifndef __KGSL_H
 #define __KGSL_H
@@ -350,6 +350,8 @@ struct kgsl_mem_entry {
 	 * debugfs accounting
 	 */
 	atomic_t map_count;
+	/** @vbo_count: Count how many VBO ranges this entry is mapped in */
+	atomic_t vbo_count;
 };
 
 struct kgsl_device_private;
diff --git a/drivers/gpu/msm/kgsl_reclaim.c b/drivers/gpu/msm/kgsl_reclaim.c
index 4b38b5501eeda..3c24c3eed534a 100644
--- a/drivers/gpu/msm/kgsl_reclaim.c
+++ b/drivers/gpu/msm/kgsl_reclaim.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2022, 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/kthread.h>
@@ -266,6 +266,13 @@ static u32 kgsl_reclaim_process(struct kgsl_process_private *process,
 			continue;
 		}
 
+		/* Do not reclaim pages mapped into a VBO */
+		if (atomic_read(&valid_entry->vbo_count)) {
+			kgsl_mem_entry_put(entry);
+			next++;
+			continue;
+		}
+
 		if ((atomic_read(&process->unpinned_page_count) +
 			memdesc->page_count) > kgsl_reclaim_max_page_limit) {
 			kgsl_mem_entry_put(entry);
diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
index 2ab97c3f5ba0a..551822ba98daf 100644
--- a/drivers/gpu/msm/kgsl_vbo.c
+++ b/drivers/gpu/msm/kgsl_vbo.c
@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
 		return ERR_PTR(-EINVAL);
 	}
 
+	atomic_inc(&entry->vbo_count);
 	return range;
 }
 
 static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
 {
-	kgsl_mem_entry_put(range->entry);
+	struct kgsl_mem_entry *entry = range->entry;
+
+	atomic_dec(&entry->vbo_count);
+	kgsl_mem_entry_put(entry);
 	kfree(range);
 }
 
@@ -309,8 +313,12 @@ static void kgsl_sharedmem_free_bind_op(struct kgsl_sharedmem_bind_op *op)
 	if (IS_ERR_OR_NULL(op))
 		return;
 
-	for (i = 0; i < op->nr_ops; i++)
+	for (i = 0; i < op->nr_ops; i++) {
+		/* Decrement the vbo_count we added when creating the bind_op */
+		if (op->ops[i].entry)
+			atomic_dec(&op->ops[i].entry->vbo_count);
 		kgsl_mem_entry_put(op->ops[i].entry);
+	}
 
 	kgsl_mem_entry_put(op->target);
 
@@ -416,6 +424,9 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
 			goto err;
 		}
 
+		/* Keep the child pinned in memory */
+		atomic_inc(&entry->vbo_count);
+
 		/* Make sure the child is not a VBO */
 		if ((entry->memdesc.flags & KGSL_MEMFLAGS_VBO)) {
 			ret = -EINVAL;
-- 
GitLab

